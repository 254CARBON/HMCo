apiVersion: v1
kind: ConfigMap
metadata:
  name: websocket-gateway-config
  namespace: data-platform
  labels:
    app: websocket-gateway
data:
  config.yaml: |
    server:
      port: 8080
      host: 0.0.0.0
    kafka:
      brokers:
        - kafka-service:9092
      topics:
        realtime_prices: "realtime.commodity.prices"
        realtime_events: "realtime.market.events"
        alerts: "realtime.alerts"
    websocket:
      max_connections: 10000
      ping_interval: 30
      message_buffer: 1000
    authentication:
      enabled: true
      jwt_secret_env: JWT_SECRET
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: websocket-gateway
  namespace: data-platform
  labels:
    app: websocket-gateway
    component: streaming-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: websocket-gateway
  template:
    metadata:
      labels:
        app: websocket-gateway
        component: streaming-api
    spec:
      containers:
      - name: websocket-gateway
        image: node:20-alpine
        workingDir: /app
        command:
        - /bin/sh
        - -c
        - |
          cat > package.json <<'EOF'
          {
            "name": "websocket-gateway",
            "version": "1.0.0",
            "dependencies": {
              "ws": "^8.14.2",
              "kafkajs": "^2.2.4",
              "express": "^4.18.2",
              "jsonwebtoken": "^9.0.2",
              "yaml": "^2.3.4"
            }
          }
          EOF
          
          cat > server.js <<'EOF'
          const WebSocket = require('ws');
          const { Kafka } = require('kafkajs');
          const express = require('express');
          const jwt = require('jsonwebtoken');
          const fs = require('fs');
          const YAML = require('yaml');
          
          // Load configuration
          const config = YAML.parse(fs.readFileSync('/config/config.yaml', 'utf8'));
          
          const app = express();
          const server = require('http').createServer(app);
          const wss = new WebSocket.Server({ server, path: '/ws/stream' });
          
          // Kafka setup
          const kafka = new Kafka({
            clientId: 'websocket-gateway',
            brokers: config.kafka.brokers
          });
          
          const consumers = {};
          
          // WebSocket connection handler
          wss.on('connection', async (ws, req) => {
            console.log('New WebSocket connection');
            
            // Authentication
            const token = req.url.split('token=')[1];
            if (config.authentication.enabled && !verifyToken(token)) {
              ws.close(1008, 'Unauthorized');
              return;
            }
            
            // Subscribe to Kafka topics
            const consumer = kafka.consumer({ groupId: `ws-client-${Date.now()}` });
            await consumer.connect();
            
            // Handle subscription requests
            ws.on('message', async (message) => {
              try {
                const data = JSON.parse(message);
                
                if (data.action === 'subscribe') {
                  const topics = data.topics || ['realtime_prices'];
                  await consumer.subscribe({ topics: topics.map(t => config.kafka.topics[t]) });
                  
                  consumer.run({
                    eachMessage: async ({ topic, partition, message }) => {
                      if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                          topic,
                          key: message.key?.toString(),
                          value: JSON.parse(message.value.toString()),
                          timestamp: message.timestamp
                        }));
                      }
                    }
                  });
                  
                  ws.send(JSON.stringify({ status: 'subscribed', topics }));
                }
                
                if (data.action === 'unsubscribe') {
                  await consumer.disconnect();
                  ws.send(JSON.stringify({ status: 'unsubscribed' }));
                }
              } catch (err) {
                console.error('Message error:', err);
                ws.send(JSON.stringify({ error: err.message }));
              }
            });
            
            ws.on('close', async () => {
              console.log('WebSocket closed');
              await consumer.disconnect();
            });
            
            // Send ping every 30 seconds
            const pingInterval = setInterval(() => {
              if (ws.readyState === WebSocket.OPEN) {
                ws.ping();
              } else {
                clearInterval(pingInterval);
              }
            }, config.websocket.ping_interval * 1000);
          });
          
          function verifyToken(token) {
            if (!token) return false;
            try {
              jwt.verify(token, process.env.JWT_SECRET || 'dev-secret');
              return true;
            } catch (err) {
              return false;
            }
          }
          
          // Health check endpoint
          app.get('/health', (req, res) => {
            res.json({ 
              status: 'healthy',
              connections: wss.clients.size,
              uptime: process.uptime()
            });
          });
          
          // Metrics endpoint
          app.get('/metrics', (req, res) => {
            res.json({
              websocket_connections: wss.clients.size,
              uptime_seconds: process.uptime()
            });
          });
          
          const PORT = config.server.port;
          server.listen(PORT, config.server.host, () => {
            console.log(`WebSocket gateway running on port ${PORT}`);
          });
          EOF
          
          npm install --production
          node server.js
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        env:
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secret
              key: secret
              optional: true
        resources:
          requests:
            cpu: 500m
            memory: 512Mi
          limits:
            cpu: 1
            memory: 1Gi
        volumeMounts:
        - name: config
          mountPath: /config
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: config
        configMap:
          name: websocket-gateway-config
---
apiVersion: v1
kind: Service
metadata:
  name: websocket-gateway
  namespace: data-platform
  labels:
    app: websocket-gateway
spec:
  type: ClusterIP
  selector:
    app: websocket-gateway
  ports:
  - name: http
    port: 8080
    targetPort: 8080
    protocol: TCP
---
apiVersion: v1
kind: Secret
metadata:
  name: jwt-secret
  namespace: data-platform
type: Opaque
stringData:
  secret: "change-this-jwt-secret-in-production-must-be-32-chars-minimum"
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: websocket-gateway
  namespace: data-platform
  labels:
    app: websocket-gateway
spec:
  selector:
    matchLabels:
      app: websocket-gateway
  endpoints:
  - port: http
    path: /metrics
    interval: 30s



